<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CSU – Semester Course Separation Tool</title>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
    :root {
        --csu-primary: #0d5540;
        --csu-secondary: #17375f;
        --csu-accent: #7bba4c;
        --csu-light: #f4f7f6;
        --csu-border: #d0d7d3;
        --csu-warn: #d9534f;
        --csu-muted: #6c757d;
    }

    body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: #ffffff;
        color: var(--csu-secondary);
    }

    header {
        background: linear-gradient(135deg, var(--csu-primary), var(--csu-secondary));
        color: #ffffff;
        padding: 1.5rem 1rem;
        text-align: center;
    }

    header h1 {
        margin: 0 0 0.3rem 0;
    }

    main {
        max-width: 1100px;
        margin: 1.5rem auto 2.5rem;
        padding: 0 1rem;
    }

    .card {
        background: var(--csu-light);
        padding: 1.25rem 1.5rem;
        border-radius: 8px;
        border: 1px solid var(--csu-border);
        margin-bottom: 1.25rem;
    }

    .card h2 {
        margin-top: 0;
        color: var(--csu-primary);
    }

    label {
        font-weight: bold;
        display: block;
        margin-bottom: 0.3rem;
    }

    input[type="file"] {
        margin-bottom: 0.75rem;
    }

    button {
        padding: 0.6rem 0.95rem;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 0.95rem;
        margin-right: 0.5rem;
    }

    button.primary {
        background: var(--csu-primary);
        color: #ffffff;
    }

    button.secondary {
        background: #ffffff;
        color: var(--csu-secondary);
        border: 1px solid var(--csu-border);
    }

    button:disabled {
        opacity: 0.5;
        cursor: default;
    }

    .status {
        margin-top: 0.5rem;
        font-size: 0.9rem;
    }

    .status.ok {
        color: var(--csu-primary);
    }

    .status.warn {
        color: var(--csu-warn);
    }

    .status.muted {
        color: var(--csu-muted);
    }

    #mappingInfo {
        font-size: 0.8rem;
        margin-top: 0.25rem;
    }

    #summaryList {
        list-style: none;
        padding-left: 0;
    }

    #summaryList li {
        margin-bottom: 0.2rem;
    }

    .sheet-preview {
        margin-bottom: 1.25rem;
    }

    .sheet-preview h3 {
        margin: 0 0 0.3rem 0;
    }

    .badge {
        display: inline-block;
        padding: 0.15rem 0.35rem;
        border-radius: 3px;
        border: 1px solid var(--csu-border);
        background: #ffffff;
        font-size: 0.7rem;
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 0.4rem;
        font-size: 0.85rem;
        background: #ffffff;
    }

    th, td {
        border: 1px solid var(--csu-border);
        padding: 0.25rem 0.4rem;
        white-space: nowrap;
    }

    th {
        background: #e7eeeb;
        position: sticky;
        top: 0;
    }
</style>
</head>

<body>

<header>
    <h1>CSU Semester Course Separation Tool</h1>
    <p>Uses CRN / XLST with TERM_CODE_KEY to build Brightspace codes.</p>
</header>

<main>

<section class="card">
    <h2>1. Upload semester spreadsheet</h2>
    <p>
        <small>
            Required term column header: <code>TERM_CODE_KEY</code> (or <code>TERM_CODE</code>), any position.<br>
            Other expected headers (any order): <code>CRN</code>, <code>XLST</code>, <code>STAT</code>, <code>CR</code>, <code>PTM</code>, <code>SUBJ</code>, <code>SEC</code>.<br>
            Brightspace code is stored in a separate <code>BrightspaceCode</code> column.
        </small>
    </p>

    <label for="fileInput">Semester file</label>
    <input id="fileInput" type="file" accept=".xlsx,.xls,.csv,.ods">

    <div>
        <button id="processBtn" class="primary" disabled>Process &amp; Separate</button>
        <button id="downloadBtn" class="secondary" disabled>Download Workbook</button>
    </div>

    <div id="status" class="status muted">No file loaded yet.</div>
    <div id="mappingInfo" class="status muted"></div>
</section>

<section class="card">
    <h2>2. Preview &amp; sheet summary</h2>
    <p><small>Preview shows first 5 rows per sheet. Use <code>BrightspaceCode</code> and <code>PTM_Group</code> in Excel for filtering.</small></p>
    <ul id="summaryList"></ul>
    <div id="preview"></div>
</section>

</main>

<script>
    const SHEET_ORDER = [
        "PHAR",
        "UNIV",
        "OLHY",
        "Zero_Credit",
        "Cancelled",
        "Other_Active",
        "Crosslisted"   // extra sheet with all rows where XLST is populated
    ];

    let separatedSheets = null;
    let baseHeaders = [];
    let columnMap = null;
    let lastTermCode = "";
    let lastFileName = "";

    function normalize(str) {
        return String(str || "").trim().toUpperCase().replace(/[\s_]+/g, "");
    }

    // Map logical fields to actual headers, based on your known header names (order flexible).
    function buildColumnMap(row) {
        const keys = Object.keys(row);
        const normMap = {};
        keys.forEach(k => { normMap[normalize(k)] = k; });

        const map = {};
        function mapField(logical, expectedNorms) {
            for (const n of expectedNorms) {
                if (normMap[n]) {
                    map[logical] = normMap[n];
                    return;
                }
            }
        }

        // TERM_CODE from TERM_CODE_KEY or TERM_CODE
        mapField("TERM_CODE", ["TERM_CODE_KEY", "TERM_CODE"]);
        mapField("CRN",       ["CRN"]);
        mapField("XLST",      ["XLST"]);
        mapField("STAT",      ["STAT"]);
        mapField("CR",        ["CR"]);
        mapField("PTM",       ["PTM"]);
        mapField("SUBJ",      ["SUBJ"]);
        mapField("SEC",       ["SEC"]);

        return map;
    }

    function getVal(row, map, logical) {
        const key = map[logical];
        if (!key) return "";
        return row[key];
    }

    function toUpperString(v) {
        if (v === undefined || v === null) return "";
        return String(v).trim().toUpperCase();
    }

    function toNumber(v) {
        if (v === undefined || v === null || v === "") return NaN;
        const n = parseFloat(v);
        return isNaN(n) ? NaN : n;
    }

    function getSectionNumber(secRaw) {
        const s = String(secRaw || "").trim();
        const m = s.match(/^(\d{1,3})/);
        return m ? parseInt(m[1], 10) : NaN;
    }

    function isUnivSection(secRaw) {
        const n = getSectionNumber(secRaw);
        if (isNaN(n)) return false;
        return (n >= 1 && n <= 19) || (n >= 61 && n <= 69);
    }

    function isOlhySection(secRaw) {
        const n = getSectionNumber(secRaw);
        if (isNaN(n)) return false;
        return (n >= 21 && n <= 29) || (n >= 51 && n <= 59);
    }

    function getPtmGroupLabel(ptm) {
        switch (ptm) {
            case "1":   return "16-week";
            case "5":   return "12-week";
            case "81T": return "1st 8-weeks";
            case "82T": return "2nd 8-weeks";
            case "DDS": return "Dynamic";
            case "H":   return "Hybrid";
            case "R5":  return "Rise Cohort 5";
            case "W":   return "Distance / Web";
            case "ZDC": return "Dual Credit";
            default:    return ptm || "";
        }
    }

    function computeBrightspaceCode(row, map) {
        if (!map.TERM_CODE) return "";
        const termRaw = getVal(row, map, "TERM_CODE");
        const term = termRaw === undefined || termRaw === null ? "" : String(termRaw).trim();
        if (!term) return "";

        const crnRaw = getVal(row, map, "CRN");
        const xlstRaw = getVal(row, map, "XLST");
        const crn = crnRaw === undefined || crnRaw === null ? "" : String(crnRaw).trim();
        const xlst = xlstRaw === undefined || xlstRaw === null ? "" : String(xlstRaw).trim();

        if (xlst) return xlst + term;
        if (crn)  return crn + "." + term;
        return "";
    }

    function separateRows(rows, map) {
        const buckets = {
            PHAR: [],
            UNIV: [],
            OLHY: [],
            Zero_Credit: [],
            Cancelled: [],
            Other_Active: [],
            Crosslisted: []
        };

        let firstTerm = "";
        let codeCount = 0;

        rows.forEach(row => {
            const outRow = { ...row };

            const stat = toUpperString(getVal(row, map, "STAT"));
            const cr = toNumber(getVal(row, map, "CR"));
            const subj = toUpperString(getVal(row, map, "SUBJ"));
            const sec = toUpperString(getVal(row, map, "SEC"));
            const termVal = getVal(row, map, "TERM_CODE");
            const term = termVal === undefined || termVal === null ? "" : String(termVal).trim();
            const ptmVal = toUpperString(getVal(row, map, "PTM"));

            const xlstRaw = getVal(row, map, "XLST");
            const xlst = xlstRaw === undefined || xlstRaw === null ? "" : String(xlstRaw).trim();

            if (!firstTerm && term) firstTerm = term;

            const code = computeBrightspaceCode(row, map);
            if (code) codeCount++;
            outRow.BrightspaceCode = code;
            outRow.PTM_Group = getPtmGroupLabel(ptmVal);

            // Crosslisted sheet: every row with a non-empty XLST
            if (xlst && xlst !== "") {
                buckets.Crosslisted.push(outRow);
            }

            let sheetName = "Other_Active";

            if (stat === "C") {
                sheetName = "Cancelled";
            } else if (!isNaN(cr) && cr === 0) {
                sheetName = "Zero_Credit";
            } else if (subj === "PHAR") {
                sheetName = "PHAR";
            } else if (isUnivSection(sec)) {
                sheetName = "UNIV";
            } else if (isOlhySection(sec)) {
                sheetName = "OLHY";
            }

            buckets[sheetName].push(outRow);
        });

        return { buckets, firstTerm, codeCount };
    }

    function computeHeadersFromSheets(buckets) {
        let headers = baseHeaders && baseHeaders.length ? baseHeaders.slice() : [];

        const allKeys = new Set(headers);
        Object.values(buckets).forEach(rows => {
            rows.forEach(row => {
                Object.keys(row).forEach(k => allKeys.add(k));
            });
        });

        if (!headers.length) {
            headers = Array.from(allKeys);
        } else {
            allKeys.forEach(k => {
                if (!headers.includes(k)) headers.push(k);
            });
        }

        if (!headers.includes("BrightspaceCode")) headers.push("BrightspaceCode");
        if (!headers.includes("PTM_Group")) headers.push("PTM_Group");

        return headers;
    }

    function setStatus(text, cls) {
        const el = document.getElementById("status");
        el.textContent = text;
        el.className = "status " + (cls || "muted");
    }

    function showMappingInfo(map) {
        const el = document.getElementById("mappingInfo");
        if (!map) {
            el.textContent = "";
            return;
        }
        const parts = ["TERM_CODE", "CRN", "XLST", "STAT", "CR", "PTM", "SUBJ", "SEC"]
            .map(k => `${k}: ${map[k] || "NOT FOUND"}`);
        el.textContent = "Mapped columns → " + parts.join(" | ");
    }

    function renderSummary(buckets) {
        const ul = document.getElementById("summaryList");
        ul.innerHTML = "";
        SHEET_ORDER.forEach(name => {
            const count = (buckets[name] || []).length;
            const li = document.createElement("li");
            li.innerHTML = `<strong>${name}</strong>: ${count} rows`;
            ul.appendChild(li);
        });
    }

    function renderPreview(buckets) {
        const container = document.getElementById("preview");
        container.innerHTML = "";

        SHEET_ORDER.forEach(name => {
            const rows = buckets[name] || [];
            if (!rows.length) return;

            const section = document.createElement("div");
            section.className = "sheet-preview";

            const count = rows.length;
            section.innerHTML = `<h3>${name} <span class="badge">${count} rows</span></h3>
                                 <small>First 5 rows</small>`;

            const table = document.createElement("table");
            const thead = document.createElement("thead");
            const tbody = document.createElement("tbody");

            const sampleRow = rows[0];
            const headers = Object.keys(sampleRow);

            const trHead = document.createElement("tr");
            headers.forEach(h => {
                const th = document.createElement("th");
                th.textContent = h;
                trHead.appendChild(th);
            });
            thead.appendChild(trHead);

            const maxRows = Math.min(5, rows.length);
            for (let i = 0; i < maxRows; i++) {
                const row = rows[i];
                const tr = document.createElement("tr");
                headers.forEach(h => {
                    const td = document.createElement("td");
                    td.textContent = row[h] === undefined ? "" : row[h];
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            }

            table.appendChild(thead);
            table.appendChild(tbody);
            section.appendChild(table);
            container.appendChild(section);
        });
    }

    function downloadWorkbook() {
        if (!separatedSheets) {
            alert("Please process a file first.");
            return;
        }

        const wb = XLSX.utils.book_new();
        const headers = computeHeadersFromSheets(separatedSheets);

        SHEET_ORDER.forEach(name => {
            const rows = separatedSheets[name] || [];
            if (!rows.length) return;
            const ws = XLSX.utils.json_to_sheet(rows, { header: headers });
            XLSX.utils.book_append_sheet(wb, ws, name.substring(0, 31));
        });

        const term = lastTermCode || "term";
        const safeName = (lastFileName || "courses")
            .replace(/\.[^.]+$/, "")
            .replace(/[^\w\-]+/g, "_") || "courses";

        const outName = `${safeName}_Separated_${term}.xlsx`;
        XLSX.writeFile(wb, outName);
    }

    function handleFileSelected(evt) {
        const file = evt.target.files[0];
        separatedSheets = null;
        baseHeaders = [];
        columnMap = null;
        lastTermCode = "";
        lastFileName = file ? file.name : "";
        document.getElementById("summaryList").innerHTML = "";
        document.getElementById("preview").innerHTML = "";
        document.getElementById("downloadBtn").disabled = true;
        showMappingInfo(null);

        if (!file) {
            setStatus("No file selected.", "muted");
            document.getElementById("processBtn").disabled = true;
            return;
        }

        setStatus(`Loaded file: ${file.name}. Click "Process & Separate" when ready.`, "ok");
        document.getElementById("processBtn").disabled = false;
    }

    function processFile() {
        const input = document.getElementById("fileInput");
        const file = input.files[0];
        if (!file) {
            alert("Please choose a file first.");
            return;
        }

        setStatus("Reading file and processing rows...", "muted");
        document.getElementById("processBtn").disabled = true;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const wb = XLSX.read(e.target.result, { type: "array" });
                const firstSheetName = wb.SheetNames[0];
                const ws = wb.Sheets[firstSheetName];
                const rows = XLSX.utils.sheet_to_json(ws, { defval: "" });

                if (!rows.length) {
                    setStatus("Sheet is empty or could not be read.", "warn");
                    document.getElementById("processBtn").disabled = false;
                    return;
                }

                baseHeaders = Object.keys(rows[0]);
                columnMap = buildColumnMap(rows[0]);
                showMappingInfo(columnMap);

                const required = ["TERM_CODE", "CRN"];
                const missingRequired = required.filter(r => !columnMap[r]);
                if (missingRequired.length) {
                    setStatus("Missing required columns: " + missingRequired.join(", ") +
                              ". Check that TERM_CODE_KEY and CRN exist.", "warn");
                    document.getElementById("processBtn").disabled = false;
                    return;
                }

                const { buckets, firstTerm, codeCount } = separateRows(rows, columnMap);
                separatedSheets = buckets;
                lastTermCode = firstTerm || "";

                renderSummary(buckets);
                renderPreview(buckets);
                document.getElementById("downloadBtn").disabled = false;
                document.getElementById("processBtn").disabled = false;

                if (codeCount === 0) {
                    setStatus("Processed, but no Brightspace codes were generated. Check CRN/XLST and TERM_CODE_KEY values.", "warn");
                } else {
                    setStatus(`Separation complete. Brightspace codes generated for ${codeCount} row(s).`, "ok");
                }
            } catch (err) {
                console.error(err);
                setStatus("Error processing file. Check the format and try again.", "warn");
                document.getElementById("processBtn").disabled = false;
            }
        };

        reader.onerror = function() {
            setStatus("Error reading file. Please try again.", "warn");
            document.getElementById("processBtn").disabled = false;
        };

        reader.readAsArrayBuffer(file);
    }

    document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("fileInput").addEventListener("change", handleFileSelected);
        document.getElementById("processBtn").addEventListener("click", processFile);
        document.getElementById("downloadBtn").addEventListener("click", downloadWorkbook);
    });
</script>

</body>
</html>
