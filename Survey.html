<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CSU – Semester Course Separation Tool</title>
<!-- SheetJS for reading/writing Excel/ODS/CSV -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
    :root {
        --csu-primary: #0d5540;
        --csu-secondary: #17375f;
        --csu-accent: #7bba4c;
        --csu-light: #f4f7f6;
        --csu-border: #d0d7d3;
        --csu-warn: #d9534f;
        --csu-muted: #6c757d;
    }

    * {
        box-sizing: border-box;
    }

    body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: #ffffff;
        color: var(--csu-secondary);
        line-height: 1.5;
    }

    header {
        background: linear-gradient(135deg, var(--csu-primary), var(--csu-secondary));
        color: #ffffff;
        padding: 1.5rem 1rem;
        text-align: center;
    }

    header h1 {
        margin: 0 0 0.25rem 0;
        font-size: 1.6rem;
        letter-spacing: 0.03em;
    }

    header p {
        margin: 0;
        font-size: 0.95rem;
        opacity: 0.95;
    }

    main {
        max-width: 1100px;
        margin: 1.5rem auto 2.5rem;
        padding: 0 1rem;
    }

    .card {
        background: var(--csu-light);
        border-radius: 8px;
        padding: 1.25rem 1.5rem;
        border: 1px solid var(--csu-border);
        box-shadow: 0 2px 4px rgba(0,0,0,0.04);
        margin-bottom: 1.25rem;
    }

    .card h2 {
        margin-top: 0;
        font-size: 1.25rem;
        color: var(--csu-primary);
    }

    .card small {
        color: var(--csu-muted);
    }

    label {
        font-weight: bold;
        display: block;
        margin-bottom: 0.3rem;
    }

    input[type="file"] {
        display: block;
        margin-bottom: 0.75rem;
    }

    .btn-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.5rem;
    }

    button {
        border: none;
        border-radius: 4px;
        padding: 0.55rem 0.9rem;
        font-size: 0.95rem;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        transition: background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
    }

    button span.icon {
        font-weight: bold;
    }

    button.primary {
        background: var(--csu-primary);
        color: #ffffff;
    }

    button.primary:hover {
        background: #0b4634;
        transform: translateY(-1px);
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    button.secondary {
        background: #ffffff;
        color: var(--csu-secondary);
        border: 1px solid var(--csu-border);
    }

    button.secondary:hover {
        background: #f1f4f3;
    }

    button:disabled {
        opacity: 0.5;
        cursor: default;
        box-shadow: none;
        transform: none;
    }

    .status {
        margin-top: 0.5rem;
        font-size: 0.9rem;
    }

    .status.ok {
        color: var(--csu-primary);
    }

    .status.warn {
        color: var(--csu-warn);
    }

    .status.muted {
        color: var(--csu-muted);
    }

    .summary-list {
        list-style: none;
        padding-left: 0;
        margin: 0.25rem 0 0.5rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem 1.5rem;
        font-size: 0.95rem;
    }

    .summary-list li strong {
        color: var(--csu-secondary);
    }

    .preview-section {
        margin-top: 0.75rem;
        max-height: 500px;
        overflow: auto;
        border-top: 1px solid var(--csu-border);
        padding-top: 0.75rem;
    }

    .sheet-preview {
        margin-bottom: 1.25rem;
    }

    .sheet-preview h3 {
        margin: 0 0 0.35rem 0;
        font-size: 1rem;
        color: var(--csu-secondary);
    }

    .sheet-preview small {
        color: var(--csu-muted);
    }

    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 0.35rem;
        font-size: 0.85rem;
        background: #ffffff;
    }

    th, td {
        padding: 0.25rem 0.4rem;
        border: 1px solid var(--csu-border);
        text-align: left;
        white-space: nowrap;
    }

    th {
        background: #e7eeeb;
        position: sticky;
        top: 0;
        z-index: 1;
        font-weight: bold;
    }

    tr:nth-child(even) td {
        background: #fafafa;
    }

    .badge {
        display: inline-block;
        padding: 0.15rem 0.35rem;
        border-radius: 3px;
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        background: #ffffff;
        border: 1px solid var(--csu-border);
        color: var(--csu-muted);
    }

    @media (max-width: 700px) {
        header h1 {
            font-size: 1.3rem;
        }
        .card {
            padding: 1rem;
        }
        th, td {
            font-size: 0.8rem;
        }
    }
</style>
</head>
<body>

<header>
    <h1>CSU Semester Course Separation Tool</h1>
    <p>Upload a semester spreadsheet, generate Brightspace codes in a separate column, and separate courses into evaluation groups.</p>
</header>

<main>
    <!-- Upload / controls -->
    <section class="card">
        <h2>1. Upload semester spreadsheet</h2>
        <p>
            <small>
                Accepted formats: <strong>.xlsx</strong>, <strong>.xls</strong>, <strong>.csv</strong>, <strong>.ods</strong><br>
                Expected columns (flexible / case-insensitive): some form of <code>CRN</code>, <code>TERM_CODE</code>, <code>XLST</code>, 
                <code>STAT</code>, <code>CR</code>, <code>PTM</code>, <code>SUBJ</code>, <code>SEC</code>.<br>
                The computed Brightspace code is stored in a separate <code>BrightspaceCode</code> column only
                (original columns and order are preserved).
            </small>
        </p>

        <label for="fileInput">Semester file</label>
        <input id="fileInput" type="file" accept=".xlsx,.xls,.csv,.ods" />

        <div class="btn-row">
            <button id="processBtn" class="primary" disabled>
                <span class="icon">▶</span>
                Process &amp; Separate Courses
            </button>
            <button id="downloadBtn" class="secondary" disabled>
                <span class="icon">⬇</span>
                Download New Workbook
            </button>
        </div>
        <div id="status" class="status muted">No file loaded yet.</div>
        <div id="mappingInfo" class="status muted" style="margin-top:0.25rem;font-size:0.8rem;"></div>
    </section>

    <!-- Preview -->
    <section class="card">
        <h2>Preview &amp; sheet summary</h2>
        <p><small>The preview shows counts per sheet and the first few rows from each sheet. Download to get the full workbook. PTM is not color-coded here; use <code>PTM</code> or <code>PTM_Group</code> in Excel for filtering.</small></p>
        <ul id="summaryList" class="summary-list"></ul>
        <div id="preview" class="preview-section"></div>
    </section>
</main>

<script>
    const SHEET_ORDER = [
        "PHAR",
        "UNIV",
        "OLHY",
        "Zero_Credit",
        "Cancelled",
        "Other_Active"
    ];

    // ---- State ----
    let originalRows = [];
    let separatedSheets = null;
    let columnMap = null;
    let lastTermCode = "";
    let lastFileName = "";
    let baseHeaders = [];

    // ---- Helpers for column mapping ----
    function normalizeHeader(str) {
        return String(str || "")
            .trim()
            .toUpperCase()
            .replace(/[\s_]+/g, "");
    }

    function buildColumnMap(exampleRow) {
        if (!exampleRow) return {};
        const map = {};
        const keys = Object.keys(exampleRow);

        // First pass: exactish mapping via normalized names
        const targetDefs = {
            CRN:       ["CRN", "COURSECRN"],
            TERM_CODE: ["TERM_CODE", "TERMCODE", "TERM"],
            XLST:      ["XLST", "CROSSLIST", "CROSS_LIST", "XLSTCODE"],
            STAT:      ["STAT", "STATUS"],
            CR:        ["CR", "CREDITS", "CREDIT", "CREDITHOURS", "CREDIT_HRS"],
            PTM:       ["PTM", "PARTOFTERM", "SESSION"],
            SUBJ:      ["SUBJ", "SUBJECT"],
            SEC:       ["SEC", "SECTION"]
        };

        keys.forEach(key => {
            const norm = normalizeHeader(key);
            Object.entries(targetDefs).forEach(([logical, candidates]) => {
                if (!map[logical] && candidates.some(c => c === norm)) {
                    map[logical] = key;
                }
            });
        });

        // Second pass: fallback – substring searches
        keys.forEach(key => {
            const up = String(key).toUpperCase();
            if (!map.CRN && up.includes("CRN")) map.CRN = key;
            if (!map.TERM_CODE && up.includes("TERM")) map.TERM_CODE = key;
            if (!map.XLST && (up.includes("XLST") || up.includes("CROSS"))) map.XLST = key;
            if (!map.STAT && (up.includes("STAT") || up.includes("STATUS"))) map.STAT = key;
            if (!map.CR && (up.includes("CREDIT") || up === "CR")) map.CR = key;
            if (!map.PTM && (up.includes("PTM") || up.includes("PART") || up.includes("SESSION"))) map.PTM = key;
            if (!map.SUBJ && (up.includes("SUBJ") || up.includes("SUBJECT"))) map.SUBJ = key;
            if (!map.SEC && (up.includes("SEC") || up.includes("SECTION"))) map.SEC = key;
        });

        return map;
    }

    function showMappingInfo(map) {
        const el = document.getElementById("mappingInfo");
        if (!map) {
            el.textContent = "";
            return;
        }
        el.textContent =
            "Mapped columns → " +
            ["CRN","TERM_CODE","XLST","STAT","CR","PTM","SUBJ","SEC"]
                .map(k => `${k}: ${map[k] || "NOT FOUND"}`)
                .join(" | ");
    }

    function getVal(row, map, logical) {
        const key = map[logical];
        if (!key) return "";
        return row[key];
    }

    function toUpperString(value) {
        if (value === undefined || value === null) return "";
        return String(value).trim().toUpperCase();
    }

    function toNumber(value) {
        if (value === undefined || value === null || value === "") return NaN;
        const n = parseFloat(value);
        return isNaN(n) ? NaN : n;
    }

    // ---- UNIV / OLHY section helpers ----
    function getSectionNumber(secRaw) {
        const s = String(secRaw || "").trim();
        const match = s.match(/^(\d{1,3})/);
        if (!match) return NaN;
        return parseInt(match[1], 10);
    }

    function isUnivSection(secRaw) {
        const n = getSectionNumber(secRaw);
        if (isNaN(n)) return false;
        // SEC 61–69 and 1 / 01–19
        if (n >= 61 && n <= 69) return true;
        if (n >= 1 && n <= 19) return true;
        return false;
    }

    function isOlhySection(secRaw) {
        const n = getSectionNumber(secRaw);
        if (isNaN(n)) return false;
        // SEC 21–29 and 51–59
        if (n >= 21 && n <= 29) return true;
        if (n >= 51 && n <= 59) return true;
        return false;
    }

    // PTM group label for Excel column
    function getPtmGroupLabel(ptm) {
        switch (ptm) {
            case "1":   return "16-week";
            case "5":   return "12-week";
            case "81T": return "1st 8-weeks";
            case "82T": return "2nd 8-weeks";
            case "DDS": return "Dynamic";
            case "H":   return "Hybrid";
            case "R5":  return "Rise Cohort 5";
            case "W":   return "Distance / Web";
            case "ZDC": return "Dual Credit";
            default:    return ptm || "";
        }
    }

    // ---- Brightspace code logic ----
    function computeBrightspaceCode(row, map) {
        if (!map || (!map.TERM_CODE) || (!map.CRN && !map.XLST)) return "";

        const termRaw = getVal(row, map, "TERM_CODE");
        const term = termRaw === undefined || termRaw === null ? "" : String(termRaw).trim();
        const crnRaw = getVal(row, map, "CRN");
        const xlstRaw = getVal(row, map, "XLST");

        const crn = crnRaw === undefined || crnRaw === null ? "" : String(crnRaw).trim();
        const xlst = xlstRaw === undefined || xlstRaw === null ? "" : String(xlstRaw).trim();

        if (!term) return "";

        if (xlst) {
            // XLST present: XLST + term_code (no dot)
            return xlst + term;
        } else if (crn) {
            // No XLST: CRN + "." + term_code
            return crn + "." + term;
        }
        return "";
    }

    // ---- Separation logic ----
    function separateRows(rows, map) {
        const buckets = {
            "PHAR": [],
            "UNIV": [],
            "OLHY": [],
            "Zero_Credit": [],
            "Cancelled": [],
            "Other_Active": []
        };

        let firstTerm = "";
        let codeCount = 0;

        rows.forEach((row) => {
            const outRow = Object.assign({}, row); // preserve original
            const stat = toUpperString(getVal(row, map, "STAT"));
            const cr = toNumber(getVal(row, map, "CR"));
            const subj = toUpperString(getVal(row, map, "SUBJ"));
            const sec = toUpperString(getVal(row, map, "SEC"));
            const termVal = getVal(row, map, "TERM_CODE");
            const term = termVal === undefined || termVal === null ? "" : String(termVal).trim();
            const ptmVal = toUpperString(getVal(row, map, "PTM"));

            if (!firstTerm && term) {
                firstTerm = term;
            }

            const brightspaceCode = computeBrightspaceCode(row, map);
            if (brightspaceCode) codeCount++;
            outRow["BrightspaceCode"] = brightspaceCode;
            outRow["PTM_Group"] = getPtmGroupLabel(ptmVal);

            let sheetName = "Other_Active";

            if (stat === "C") {
                sheetName = "Cancelled";
            } else if (!isNaN(cr) && cr === 0) {
                sheetName = "Zero_Credit";
            } else {
                if (subj === "PHAR") {
                    sheetName = "PHAR";
                } else if (isUnivSection(sec)) {
                    sheetName = "UNIV";
                } else if (isOlhySection(sec)) {
                    sheetName = "OLHY";
                } else {
                    sheetName = "Other_Active";
                }
            }

            buckets[sheetName].push(outRow);
        });

        return { buckets, firstTerm, codeCount };
    }

    // ---- Workbook writer ----
    function computeHeadersFromSheets(buckets) {
        // Preserve original order, then append any new columns
        let headers = baseHeaders && baseHeaders.length ? baseHeaders.slice() : [];

        const allKeys = new Set(headers);
        Object.values(buckets).forEach(rows => {
            rows.forEach(row => {
                Object.keys(row).forEach(k => allKeys.add(k));
            });
        });

        if (!headers.length) {
            headers = Array.from(allKeys);
        } else {
            allKeys.forEach(k => {
                if (!headers.includes(k)) headers.push(k);
            });
        }

        // Ensure BrightspaceCode and PTM_Group at end
        if (!headers.includes("BrightspaceCode")) headers.push("BrightspaceCode");
        if (!headers.includes("PTM_Group")) headers.push("PTM_Group");

        return headers;
    }

    function downloadWorkbook() {
        if (!separatedSheets) {
            alert("Please process a file first.");
            return;
        }

        const wb = XLSX.utils.book_new();
        const headers = computeHeadersFromSheets(separatedSheets);

        SHEET_ORDER.forEach(name => {
            const rows = separatedSheets[name] || [];
            if (!rows.length) return;
            const ws = XLSX.utils.json_to_sheet(rows, { header: headers });
            XLSX.utils.book_append_sheet(wb, ws, name.substring(0, 31));
        });

        const term = lastTermCode || "term";
        const safeName = (lastFileName || "courses")
            .replace(/\.[^.]+$/, "")
            .replace(/[^\w\-]+/g, "_")
            || "courses";

        const outName = `${safeName}_Separated_${term}.xlsx`;
        XLSX.writeFile(wb, outName);
    }

    // ---- UI helpers ----
    function setStatus(text, cls) {
        const statusEl = document.getElementById("status");
        statusEl.textContent = text;
        statusEl.className = "status " + (cls || "muted");
    }

    function renderSummary(buckets) {
        const summaryEl = document.getElementById("summaryList");
        summaryEl.innerHTML = "";
        const frag = document.createDocumentFragment();

        SHEET_ORDER.forEach(name => {
            const li = document.createElement("li");
            const count = (buckets[name] || []).length;
            li.innerHTML = `<strong>${name}</strong>: ${count} rows`;
            frag.appendChild(li);
        });

        summaryEl.appendChild(frag);
    }

    function renderPreviewTables(buckets) {
        const previewEl = document.getElementById("preview");
        previewEl.innerHTML = "";

        SHEET_ORDER.forEach(name => {
            const rows = buckets[name] || [];
            if (!rows.length) return;

            const section = document.createElement("div");
            section.className = "sheet-preview";

            const count = rows.length;
            section.innerHTML = `<h3>${name} <span class="badge">${count} rows</span></h3>
                <small>Showing first 5 rows.</small>`;

            const table = document.createElement("table");
            const thead = document.createElement("thead");
            const tbody = document.createElement("tbody");

            const sampleRow = rows[0];
            const headers = Object.keys(sampleRow);

            // header row
            const trHead = document.createElement("tr");
            headers.forEach(h => {
                const th = document.createElement("th");
                th.textContent = h;
                trHead.appendChild(th);
            });
            thead.appendChild(trHead);

            // first 5 rows
            const maxRows = Math.min(5, rows.length);
            for (let i = 0; i < maxRows; i++) {
                const row = rows[i];
                const tr = document.createElement("tr");

                headers.forEach(h => {
                    const td = document.createElement("td");
                    const value = row[h];
                    td.textContent = value === undefined ? "" : value;
                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            }

            table.appendChild(thead);
            table.appendChild(tbody);
            section.appendChild(table);
            previewEl.appendChild(section);
        });
    }

    // ---- File handling ----
    function handleFileSelected(evt) {
        const file = evt.target.files[0];
        separatedSheets = null;
        originalRows = [];
        columnMap = null;
        baseHeaders = [];
        lastTermCode = "";
        lastFileName = file ? file.name : "";
        document.getElementById("summaryList").innerHTML = "";
        document.getElementById("preview").innerHTML = "";
        document.getElementById("downloadBtn").disabled = true;
        showMappingInfo(null);

        if (!file) {
            setStatus("No file selected.", "muted");
            document.getElementById("processBtn").disabled = true;
            return;
        }

        setStatus(`Loaded file: ${file.name}. Click "Process & Separate Courses" when ready.`, "ok");
        document.getElementById("processBtn").disabled = false;
    }

    function processFile() {
        const input = document.getElementById("fileInput");
        const file = input.files[0];
        if (!file) {
            alert("Please choose a file first.");
            return;
        }

        setStatus("Reading file and processing rows...", "muted");
        document.getElementById("processBtn").disabled = true;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = e.target.result;
                const wb = XLSX.read(data, { type: "array" });

                const firstSheetName = wb.SheetNames[0];
                const ws = wb.Sheets[firstSheetName];

                const rows = XLSX.utils.sheet_to_json(ws, { defval: "" });
                if (!rows.length) {
                    setStatus("The sheet is empty or could not be read.", "warn");
                    document.getElementById("processBtn").disabled = false;
                    return;
                }

                originalRows = rows;
                baseHeaders = Object.keys(rows[0]); // preserve original column order
                columnMap = buildColumnMap(rows[0]);
                showMappingInfo(columnMap);

                const { buckets, firstTerm, codeCount } = separateRows(rows, columnMap);
                separatedSheets = buckets;
                lastTermCode = firstTerm || "";

                renderSummary(buckets);
                renderPreviewTables(buckets);
                document.getElementById("downloadBtn").disabled = false;
                document.getElementById("processBtn").disabled = false;

                if (codeCount === 0) {
                    setStatus("Processed, but no Brightspace codes were generated. Check that CRN / Term columns were detected in the mapping above.", "warn");
                } else {
                    setStatus(`Separation complete. Brightspace codes generated for ${codeCount} row(s). Review preview below or download the new workbook.`, "ok");
                }
            } catch (err) {
                console.error(err);
                setStatus("Error processing file. Check the format and try again.", "warn");
                document.getElementById("processBtn").disabled = false;
            }
        };
        reader.onerror = function() {
            setStatus("Error reading file. Please try again.", "warn");
            document.getElementById("processBtn").disabled = false;
        };

        reader.readAsArrayBuffer(file);
    }

    // ---- Init ----
    document.addEventListener("DOMContentLoaded", function() {
        document.getElementById("fileInput").addEventListener("change", handleFileSelected);
        document.getElementById("processBtn").addEventListener("click", processFile);
        document.getElementById("downloadBtn").addEventListener("click", downloadWorkbook);
    });
</script>

</body>
</html>
